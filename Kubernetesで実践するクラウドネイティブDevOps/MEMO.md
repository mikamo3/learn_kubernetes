# 2 Kubernetes最初の一歩

スタンドアロンで動かすときはminikube

立てたpodにアクセスするには

```
kubectl port-forward hogehoge 9999:8888
```

# 3 Kubernetes環境の選択

Kubernetesがコンテナのスケジューリングやサービス管理、APIリクエスト処理を実行するためのコントロールプレーンがある

ユーザのワークロードを実行するクラスタメンバはワーカーノードという

コントロールプレーンは高可用性を備えている

耐障害性を確保するため、複数のワーカーノード、アベイラビリティゾーンを分けるなど対処しておく

本番運用ではマネージドのほうが良さげ。むしろ特別な理由がないのであればセルフホスティングしないほうがいい

* GKE (google)
* EKS (amazon)
* AKE (azure)

原則

* 実行するソフトウェアを減らす
* 標準のテクノロジを選ぶ
* 差別化につながらない面倒な作業はアウトソーシングする
* 長続きする競争優位性を生み出す

# 4 Kubernetesオブジェクトの基本操作

Deployment: Kubernetesのスーパバイザ

コントローラ: 状態を望ましい状態と一致することを保証する

ReplicaSet: 同一Pod、レプリカのグループを管理する

スケジューラ: スケジューリングされていないPodのキューを監視して、そこから次のPodを取り出して実行場所となるノードを見つける

Service: PodのIPのかわりに単一の変化しないIPアドレス、DNS名が与えられ、任意の対応するPodへ自動的にルーティングされる

* port: Serviceの提供するポート
* targetPort: 対応するPodのポート
* selectorで対応するPodを指定

Helm:
  チャート: アプリケーションを実行するための必要なリリース
  リポジトリ: チャートを収集、共有できる場所
  リソース: 実行されるチャートの特定のインスタンス

# 5 リソースの管理

リソース制限: 割り当てられた制限を超えてCPUを使用しようとするPodはスロットルの対象となる
割り当てられた制限を超えてメモリを使用しようとするPodは強制終了される

Kubernetesではリソースのオーバーコミットは許容される

Podの強制終了が必要な場合、リソース要求を最も超過しているPodから強制終了する

コンテナは小さく保つ

Readiness probe: get podsに表示されるREADYの状態はこれが完了したかどうか

namespaceを分割してもservice同士は通信可能

DNS名は SERVICE.NAMESPACE.svc.cluster.local

同一名称のサービスでnamespaceをまたがるサービスにアクセスしたい場合 SERVICE.NAMESPACEでアクセス可能

namespaceでquotaを設定できる。ただしCPU,memoryを制限するのはおすすめできない

Namespace内のリソース制限、要求はデフォルトLimitRangeから取得するが明示的に記載すべき

コンテナのリソース制限は一般的に通常運用の最大量より少し多い値に設定する

node内のPodは10-100くらい

ガベージコレクションでディスクスペースが不足し始めると未使用のイメージは自動的にクリーンアップされる

# 6 クラスタの運用

クラスタのキャパシティ計画は重要

従来型のサーバでアプリケーションを動かす場合どのくらいの台数が必要か？から算出する

Kubernetesクラスタで耐障害性を実現する場合、マスタノードの最少数は3(リーダ選出の関係で2代は不適切)

ワークロードがフォールトレラントであるためには少なくとも2つのワーカーノードが必要

クラスタが大きくなるほど、マスタノードにかかる負荷は大きくなる

そのため大規模な運用が必要な場合、フェデレーションさせることによりワークロードをクラスタ間で複製できる。

これは2つ以上のクラスタを同期させて同じワークロードを実行できる

とはいえそこまで使うシチュエーションはない

ノードの追加は容易に行える。スケールダウンはドレインが行われ、ワークロードが他のノードに確実に移行されるようにする。

Kubernetesとワークロードに関してK8Guardというツールで問題をチェックできる

sonobuoyでkubernetes適合性テストを実行できる

Copperでマニフェストをデプロイする前のチェックをしてくれる

kube-benchでクラスタがセキュリティに関するベストプラクティスに準拠しているかチェックできる

監査ロギングを有効にすると、クラスタAPIに対するすべてのリクエストがログに記録される

chaosnuke,chaosmonkeyでクラスタの耐障害性をテストできる

kube-monkeyはプリセットされた時刻に実行され、対象のPodを対象にテストする

# 7 Kubernetesの強力なツール

kubectlについて

--selectorフラグでLabelに一致するリソースを対象として操作できる

リソースタイプは省略形がある

* po pod
* deploy deployment
* svc service
* ns namespace
など

--watchフラグでリソースの変更を監視できる

インフラにおいて命令的なコマンドを使う問題点は、唯一の信頼できる情報源が存在しないこと

コマンドを実行した後、何らかのマニフェストが実行されると宣言的コマンドが上書きされる

マニフェストの作成で`--dry-run -o yaml`を活用する

kubectl attachでPodにアタッチできる
kubectl execで任意のコマンドを実行できる

`alias bb=$kubectl run busybox --image=busybox:1.28 --rm -it --restart=Never$`

こんなかんじのaliasを設定しておくと便利

`bb nslookup demo` など
